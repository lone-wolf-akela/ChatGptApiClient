/*
    ChatGPT Client V2: A GUI client for the OpenAI ChatGPT API (and also Anthropic Claude API) based on WPF.
    Copyright (C) 2024 Lone Wolf Akela

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System.Runtime.Serialization;
using NJsonSchema;
using Newtonsoft.Json.Serialization;
using Newtonsoft.Json.Linq;
// ReSharper disable PropertyCanBeMadeInitOnly.Global
// ReSharper disable MemberCanBePrivate.Global
// ReSharper disable UnusedMemberInSuper.Global
// ReSharper disable AutoPropertyCanBeMadeGetOnly.Global

namespace ChatGptApiClientV2;

[JsonConverter(typeof(StringEnumConverter))]
public enum RoleType
{
    [EnumMember(Value = "system")]
    System,
    [EnumMember(Value = "user")]
    User,
    [EnumMember(Value = "assistant")]
    Assistant,
    [EnumMember(Value = "tool")]
    Tool
}

public class ToolCallType : ICloneable
{
    public class FunctionType : ICloneable
    {
        /// <summary>
        /// The name of the function to call.
        /// </summary>
        public string Name { get; set; } = "";
        /// <summary>
        /// The arguments to call the function with, as generated by the model in JSON format. 
        /// Note that the model does not always generate valid JSON, and may hallucinate 
        /// parameters not defined by your function schema. Validate the arguments in your code 
        /// before calling your function.
        /// </summary>
        public string Arguments { get; set; } = "";
        public object Clone()
        {
            return new FunctionType
            {
                Name = Name,
                Arguments = Arguments
            };
        }
    }

    /// <summary>
    /// The ID of the tool call.
    /// </summary>
    public string Id { get; set; } = "";
    public FunctionType Function { get; set; } = new();
    public object Clone()
    {
        return new ToolCallType
        {
            Id = Id,
            Function = (FunctionType)Function.Clone()
        };
    }
}

public class MessageConverter : JsonConverter<IMessage>
{
    private bool canWrite = true;
    private bool canRead = true;
    public override bool CanWrite => canWrite;
    public override bool CanRead => canRead;
    public override void WriteJson(JsonWriter writer, IMessage? value, JsonSerializer serializer)
    {
        canWrite = false;

        if (value is null)
        {
            writer.WriteNull();
        }
        else
        {
            switch (value.Role)
            {
                case RoleType.System:
                    serializer.Serialize(writer, (SystemMessage)value);
                    break;
                case RoleType.User:
                    serializer.Serialize(writer, (UserMessage)value);
                    break;
                case RoleType.Assistant:
                    serializer.Serialize(writer, (AssistantMessage)value);
                    break;
                case RoleType.Tool:
                    serializer.Serialize(writer, (ToolMessage)value);
                    break;
                default:
                    throw new JsonSerializationException();
            }
        }
        canWrite = true;
    }

    public override IMessage ReadJson(JsonReader reader, Type objectType, IMessage? existingValue, bool hasExistingValue, JsonSerializer serializer)
    {
        canRead = false;
        var jobj = JObject.Load(reader);
        var role = jobj["role"]?.ToObject<RoleType>();

        IMessage result = role switch
        {
            RoleType.System => jobj.ToObject<SystemMessage>(serializer) ?? throw new JsonSerializationException(),
            RoleType.User => jobj.ToObject<UserMessage>(serializer) ?? throw new JsonSerializationException(),
            RoleType.Assistant => jobj.ToObject<AssistantMessage>(serializer) ?? throw new JsonSerializationException(),
            RoleType.Tool => jobj.ToObject<ToolMessage>(serializer) ?? throw new JsonSerializationException(),
            _ => throw new JsonSerializationException(),
        };
        canRead = true;
        return result;
    }
}

[JsonConverter(typeof(MessageConverter))]
public interface IMessage : ICloneable
{
    [JsonConverter(typeof(StringEnumConverter))]
    public enum ContentCategory
    {
        [EnumMember(Value = "text")]
        Text,
        [EnumMember(Value = "image_url")]
        ImageUrl
    }
    public class ContentConverter : JsonConverter<IContent>
    {
        private bool canWrite = true;
        private bool canRead = true;
        public override bool CanWrite => canWrite;
        public override bool CanRead => canRead;
        public override void WriteJson(JsonWriter writer, IContent? value, JsonSerializer serializer)
        {
            canWrite = false;
            if (value is null)
            {
                writer.WriteNull();
            }
            else
            {
                switch (value.Type)
                {
                    case ContentCategory.Text:
                        serializer.Serialize(writer, (TextContent)value);
                        break;
                    case ContentCategory.ImageUrl:
                        serializer.Serialize(writer, (ImageContent)value);
                        break;
                    default:
                        throw new JsonSerializationException();
                }
            }
            canWrite = true;
        }

        public override IContent ReadJson(JsonReader reader, Type objectType, IContent? existingValue, bool hasExistingValue, JsonSerializer serializer)
        {
            canRead = false;
            var jobj = JObject.Load(reader);
            var type = jobj["type"]?.ToObject<ContentCategory>();
            IContent result = type switch
            {
                ContentCategory.Text => jobj.ToObject<TextContent>(serializer) ?? throw new JsonSerializationException(),
                ContentCategory.ImageUrl => jobj.ToObject<ImageContent>(serializer) ?? throw new JsonSerializationException(),
                _ => throw new JsonSerializationException(),
            };
            canRead = true;
            return result;
        }
    }
    [JsonConverter(typeof(ContentConverter))]
    public interface IContent : ICloneable
    {
        public ContentCategory Type { get; }
        public int CountToken();
    }
    public class TextContent : IContent
    {
        public ContentCategory Type => ContentCategory.Text;
        public int CountToken()
        {
            return Utils.GetStringTokenNum(Text);
        }

        public string Text { get; set; } = "";
        public object Clone()
        {
            return new TextContent
            {
                Text = Text
            };
        }
    }
    public class ImageContent : IContent
    {
        public class ImageUrlType : ICloneable
        {
            [JsonConverter(typeof(StringEnumConverter))]
            public enum ImageDetail
            {
                [EnumMember(Value = "low")]
                Low,
                [EnumMember(Value = "high")]
                High
            }
            public string Url { get; set; } = "";
            public ImageDetail Detail { get; set; } = ImageDetail.Low;
            public object Clone()
            {
                return new ImageUrlType
                {
                    Url = Url,
                    Detail = Detail
                };
            }
        }
        public ContentCategory Type => ContentCategory.ImageUrl;

        [JsonIgnore]
        public System.Windows.Size? ImageSize { get; set; } // cache image size
        public int CountToken()
        {
            // see https://platform.openai.com/docs/guides/vision
            const int baseTokenNum = 85;
            const int tokenPerTile = 170;
            const int tileSize = 512;

            var count = baseTokenNum;

            if (ImageUrl.Detail != ImageUrlType.ImageDetail.High)
            {
                return count;
            }

            if (ImageSize is null)
            {
                var image = Utils.Base64ToBitmapImage(ImageUrl.Url);
                ImageSize = new System.Windows.Size(image.PixelWidth, image.PixelHeight);
            }
            // if size is too large, scale down to fit in 2048x2048, keep aspect ratio
            if (ImageSize.Value.Width > 2048 || ImageSize.Value.Height > 2048)
            {
                var ratio = Math.Min(2048.0 / ImageSize.Value.Width, 2048.0 / ImageSize.Value.Height);
                ImageSize = new System.Windows.Size(Math.Round(ImageSize.Value.Width * ratio), Math.Round(ImageSize.Value.Height * ratio));
            }
            // further scale down to make the shortest side fit in 768px, keep aspect ratio
            var isWidthShorter = ImageSize.Value.Width < ImageSize.Value.Height;
            if (isWidthShorter && ImageSize.Value.Width > 768)
            {
                var ratio = 768.0 / ImageSize.Value.Width;
                ImageSize = new System.Windows.Size(Math.Round(ImageSize.Value.Width * ratio), Math.Round(ImageSize.Value.Height * ratio));
            }
            else if (!isWidthShorter && ImageSize.Value.Height > 768)
            {
                var ratio = 768.0 / ImageSize.Value.Height;
                ImageSize = new System.Windows.Size(Math.Round(ImageSize.Value.Width * ratio), Math.Round(ImageSize.Value.Height * ratio));
            }

            var tileNum = Math.Ceiling(ImageSize.Value.Width / tileSize) * Math.Ceiling(ImageSize.Value.Height / tileSize);
            count += (int)tileNum * tokenPerTile;

            return count;
        }
        public ImageUrlType ImageUrl { get; set; } = new();
        public object Clone()
        {
            return new ImageContent
            {
                ImageSize = ImageSize,
                ImageUrl = (ImageUrlType)ImageUrl.Clone()
            };
        }
    }
    /// <summary>
    /// The contents of the message.
    /// </summary>
    public IEnumerable<IContent> Content { get; set; }
    /// <summary>
    /// The role of the messages author
    /// </summary>
    public RoleType Role { get; }
    /// <summary>
    /// An optional name for the participant. Provides the model information to differentiate between participants of the same role.
    /// </summary>
    public string? Name { get; }
    public bool Hidden { get; }

    public int CountTokenBase()
    {
        var count = 3;
        foreach (var c in Content)
        {
            count += c.CountToken();
        }
        if (Name is not null)
        {
            count += 1 + Utils.GetStringTokenNum(Name);
        }
        return count;
    }
    public int CountToken();
}
public class SystemMessage : IMessage
{
    public IEnumerable<IMessage.IContent> Content { get; set; } = new List<IMessage.TextContent>();
    public RoleType Role => RoleType.System;
    public string? Name { get; set; }
    public bool Hidden => false;
    public int CountToken() => ((IMessage)this).CountTokenBase();
    public object Clone()
    {
        return new SystemMessage
        {
            Content = (from c in Content select (IMessage.IContent)c.Clone()).ToList(),
            Name = Name
        };
    }
}
public class UserMessage : IMessage
{
    public class AttachmentInfoConverter : JsonConverter<IAttachmentInfo>
    {
        private bool canWrite = true;
        private bool canRead = true;
        public override bool CanWrite => canWrite;
        public override bool CanRead => canRead;

        public override void WriteJson(JsonWriter writer, IAttachmentInfo? value, JsonSerializer serializer)
        {
            canWrite = false;
            if (value is null)
            {
                writer.WriteNull();
            }
            else
            {
                switch (value.Type)
                {
                    case IAttachmentInfo.AttachmentType.Text:
                        serializer.Serialize(writer, (TextAttachmentInfo)value);
                        break;
                    case IAttachmentInfo.AttachmentType.Image:
                        serializer.Serialize(writer, (ImageAttachmentInfo)value);
                        break;
                    default:
                        throw new JsonSerializationException();
                }
            }
            canWrite = true;
        }

        public override IAttachmentInfo ReadJson(JsonReader reader, Type objectType, IAttachmentInfo? existingValue, bool hasExistingValue, JsonSerializer serializer)
        {
            canRead = false;
            var jobj = JObject.Load(reader);
            var type = jobj["type"]?.ToObject<IAttachmentInfo.AttachmentType>();
            IAttachmentInfo result = type switch
            {
                IAttachmentInfo.AttachmentType.Text => jobj.ToObject<TextAttachmentInfo>(serializer) ?? throw new JsonSerializationException(),
                IAttachmentInfo.AttachmentType.Image => jobj.ToObject<ImageAttachmentInfo>(serializer) ?? throw new JsonSerializationException(),
                _ => throw new JsonSerializationException(),
            };
            canRead = true;
            return result;
        }
    }
    [JsonConverter(typeof(AttachmentInfoConverter))]
    public interface IAttachmentInfo : ICloneable
    {
        [JsonConverter(typeof(StringEnumConverter))]
        public enum AttachmentType
        {
            [EnumMember(Value = "text")]
            Text,
            [EnumMember(Value = "image")]
            Image
        }
        public AttachmentType Type { get; }
        public string FileName { get; }
    }
    public class TextAttachmentInfo : IAttachmentInfo
    {
        public IAttachmentInfo.AttachmentType Type => IAttachmentInfo.AttachmentType.Text;
        public string FileName { get; set; } = "";
        public string Content { get; set; } = "";
        public object Clone()
        {
            return new TextAttachmentInfo
            {
                FileName = FileName,
                Content = Content
            };
        }
    }
    public class ImageAttachmentInfo : IAttachmentInfo
    {
        public IAttachmentInfo.AttachmentType Type => IAttachmentInfo.AttachmentType.Image;
        public string FileName { get; set; } = "";
        public string ImageBase64Url { get; set; } = "";
        public bool HighResMode { get; set; }
        public System.Windows.Size? ImageSize { get; set; } // cache image size
        public object Clone()
        {
            return new ImageAttachmentInfo
            {
                FileName = FileName,
                ImageBase64Url = ImageBase64Url,
                HighResMode = HighResMode,
                ImageSize = ImageSize
            };
        }
    }
    public IEnumerable<IMessage.IContent> Content { get; set; } = new List<IMessage.IContent>();
    public RoleType Role => RoleType.User;
    public string? Name { get; set; }
    public bool Hidden => false;
    public int CountToken()
    {
        var count = ((IMessage)this).CountTokenBase();
        var attachments = GenerateAttachmentContentList();
        foreach (var c in attachments)
        {
            count += c.CountToken();
        }
        return count;
    }
    public List<IAttachmentInfo> Attachments { get; set; } = [];
    public IEnumerable<IMessage.IContent> GenerateAttachmentContentList()
    {
        List<IMessage.IContent> contents = [];
        foreach (var file in Attachments)
        {
            IMessage.IContent msg = file switch
            {
                TextAttachmentInfo textFile => new IMessage.TextContent
                {
                    Text = $"\n\nAttachment:\n\n{textFile.Content}"
                },
                ImageAttachmentInfo imageFile => new IMessage.ImageContent
                {
                    ImageUrl = new IMessage.ImageContent.ImageUrlType
                    {
                        Url = imageFile.ImageBase64Url,
                        Detail = imageFile.HighResMode
                            ? IMessage.ImageContent.ImageUrlType.ImageDetail.High
                            : IMessage.ImageContent.ImageUrlType.ImageDetail.Low
                    },
                    ImageSize = imageFile.ImageSize
                },
                _ => throw new InvalidOperationException()
            };
            contents.Add(msg);
        }
        return contents;
    }
    public object Clone()
    {
        return new UserMessage
        {
            Content = (from c in Content select (IMessage.IContent)c.Clone()).ToList(),
            Name = Name,
            Attachments = (from a in Attachments select (IAttachmentInfo)a.Clone()).ToList()
        };
    }
}
public class AssistantMessage : IMessage
{
    public IEnumerable<IMessage.IContent> Content { get; set; } = new List<IMessage.TextContent>();
    public RoleType Role => RoleType.Assistant;
    public string? Name { get; set; }
    public List<ToolCallType>? ToolCalls { get; set; }
    public bool Hidden => false;
    public int CountToken()
    {
        var count = ((IMessage)this).CountTokenBase();
        foreach (var tc in ToolCalls ?? [])
        {
            count += Utils.GetStringTokenNum(tc.Function.Name);
            count += Utils.GetStringTokenNum(tc.Function.Arguments);
        }
        return count;
    }
    public object Clone()
    {
        return new AssistantMessage
        {
            Content = (from c in Content select (IMessage.IContent)c.Clone()).ToList(),
            Name = Name,
            ToolCalls = (from t in ToolCalls select (ToolCallType)t.Clone()).ToList()
        };
    }
}
public class ToolMessage : IMessage
{
    public IEnumerable<IMessage.IContent> Content { get; set; } = new List<IMessage.TextContent>();
    public RoleType Role => RoleType.Tool;
    public string? Name => null;
    public string ToolCallId { get; set; } = "";
    [Obsolete]
    public class GeneratedImage : ICloneable
    {
        public string ImageBase64Url { get; set; } = "";
        public string Description { get; set; } = "";
        public object Clone()
        {
            return new GeneratedImage
            {
                ImageBase64Url = ImageBase64Url,
                Description = Description
            };
        }
    }
    [Obsolete]
    public List<GeneratedImage> GeneratedImages { get; set; } = [];
    public bool Hidden { get; set; }
    public int CountToken() => ((IMessage)this).CountTokenBase();
    public object Clone()
    {
        return new ToolMessage
        {
            Content = (from c in Content select (IMessage.IContent)c.Clone()).ToList(),
            ToolCallId = ToolCallId,
#pragma warning disable CS0612 // 类型或成员已过时
            GeneratedImages = (from g in GeneratedImages select (GeneratedImage)g.Clone()).ToList(),
#pragma warning restore CS0612 // 类型或成员已过时
            Hidden = Hidden
        };
    }
}
public class ChatCompletionRequest
{
    public class ToolType
    {
        public class FunctionType
        {
            public string? Description { get; set; }
            public string Name { get; set; } = "";
            public JsonSchema Parameters { get; set; } = new();
        }
        public FunctionType Function { get; set; } = new();
    }
    public List<IMessage> Messages { get; set; } = [];
    private string? title;
    public string? Title
    {
        set => title = value;
        get
        {
            if (title is not null) { return title; }
            var firstUserMessage = Messages.FirstOrDefault(m => m.Role == RoleType.User);
            var firstTextContent = firstUserMessage?.Content.FirstOrDefault(c => c.Type == IMessage.ContentCategory.Text) as IMessage.TextContent;
            var firstLine = firstTextContent?.Text.Trim().Split('\n').FirstOrDefault()?.Trim(); // need trim again at the end, to remove possible '\r'
            return firstLine;
        }
    }

    public Dictionary<string, List<string>> PluginData { get; set; } = [];

    public string Save()
    {
        var contractResolver = new DefaultContractResolver
        {
            NamingStrategy = new SnakeCaseNamingStrategy()
        };
        var settings = new JsonSerializerSettings
        {
            ContractResolver = contractResolver,
            Formatting = Formatting.Indented,
            StringEscapeHandling = StringEscapeHandling.Default,
            NullValueHandling = NullValueHandling.Ignore
        };
        var result = JsonConvert.SerializeObject(this, settings);
        return result;
    }
    public static ChatCompletionRequest BuildFromInitPrompts(
        IEnumerable<IMessage>? initPrompts,
        DateTime knowledgeCutoff,
        string productName,
        string modelProvider)
    {
        var request = new ChatCompletionRequest();
        var messages = (from msg in initPrompts select (IMessage)msg.Clone()).ToList();

        foreach (var msg in messages)
        {
            var contentList = msg.Content.ToList();
            foreach (var content in contentList)
            {
                if (content is not IMessage.TextContent textContent)
                {
                    continue;
                }
                var ci = CultureInfo.CurrentUICulture;

                var prompt = textContent.Text;
                prompt = prompt.Replace("{DateTime}", DateTime.Now.ToString("MMM dd yyy", CultureInfo.GetCultureInfo("en-US")));
                prompt = prompt.Replace("{Cutoff}", knowledgeCutoff.ToString("MMM yyyy", CultureInfo.GetCultureInfo("en-US")));
                prompt = prompt.Replace("{Language}", ci.DisplayName);
                prompt = prompt.Replace("{ProductName}", productName);
                prompt = prompt.Replace("{ModelProvider}", modelProvider);
                textContent.Text = prompt;
            }
            msg.Content = contentList;
        }
        request.Messages = messages;

        return request;
    }

    public int CountTokens()
    {
        var count = 0;
        foreach (var msg in Messages)
        {
            count += msg.CountToken();
        }
        return count;
    }
}